package main

import (
	"fmt"
	"log"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + ".go"

	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-api. DO NOT EDIT")
	g.P()
	g.P("package ", file.GoPackageName)
	// log.Printf("%v\n", file.Messages[0])
	for _, msg := range file.Messages {
		mesgStruct := messageToStruct(msg)

		for _, msgS := range mesgStruct {
			g.P(msgS)
		}
	}
	return g
}

func messageToStruct(m *protogen.Message) []string {

	mf := messageToFormat(m)

	st := generateStruct(mf)
	getters := makeGetters(mf)
	setters := makeSetters(mf)

	content := make([]string, 0)
	content = append(content, st...)
	content = append(content, getters...)
	content = append(content, setters...)
	return content
}

func capitalize(inp string) string {
	return fmt.Sprintf("%v%v", strings.ToUpper(string(inp[0])), inp[1:])
}

type GeneratableMessage struct {
	StructName string
	Fields     []MessageField
}
type MessageField struct {
	Name     string
	JSONName string
	Kind     string
}

func messageToFormat(m *protogen.Message) GeneratableMessage {
	mx := GeneratableMessage{
		StructName: strings.Replace(string(m.Desc.FullName()), "api.", "", 1),
		Fields:     make([]MessageField, 0),
	}

	for _, fx := range m.Fields {
		// if fx.
		if fx.Message != nil {
			log.Printf("FX: %v\n", fx)
		}
		mf := MessageField{
			Name:     fx.GoName,
			JSONName: fx.Desc.JSONName(),
			Kind:     kindToGoKind(fx.Desc.Kind().String()),
		}
		mx.Fields = append(mx.Fields, mf)
	}

	return mx
}

func generateStruct(m GeneratableMessage) []string {
	stringRows := make([]string, 0)
	// structName := strings.Replace(string(m.Desc.FullName()), "api.", "", 1)

	dataRows := make([]string, 0)
	for _, fx := range m.Fields {
		dataRows = append(dataRows,
			fmt.Sprintf("%v %v `json:\"%v\"`", fx.Name, fx.Kind, fx.JSONName),
		)
	}

	stringRows = append(stringRows,
		fmt.Sprintf("type %v struct {", m.StructName),
	)
	stringRows = append(stringRows, dataRows...)
	stringRows = append(stringRows, "}")
	return stringRows
}

func makeGetters(m GeneratableMessage) []string {
	stringRows := make([]string, 0)

	for _, fx := range m.Fields {
		stringRows = append(stringRows, makeGetter(fx, m.StructName)...)
	}

	return stringRows
}

func makeGetter(fx MessageField, objName string) []string {
	output := make([]string, 0)
	output = append(output,
		fmt.Sprintf("func (%v *%v) Get%v() %v {", strings.ToLower(string(objName[0])), capitalize(objName), fx.Name, fx.Kind),
		fmt.Sprintf("return %v.%v", strings.ToLower(string(objName[0])), fx.Name),
		"}",
	)
	return output
	// content := fmt.Sprintf("func (%v *%v) Get%v() %v {\n return %v.%v\n}",  )
}

func makeSetters(m GeneratableMessage) []string {
	stringRows := make([]string, 0)

	for _, fx := range m.Fields {
		stringRows = append(stringRows, makeSetter(fx, m.StructName)...)
	}

	return stringRows
}

func makeSetter(fx MessageField, objName string) []string {
	output := make([]string, 0)
	output = append(output,
		fmt.Sprintf("func (%v *%v) Set%v(val %v) {", strings.ToLower(string(objName[0])), capitalize(objName), fx.Name, fx.Kind),
		fmt.Sprintf("%v.%v = val", strings.ToLower(string(objName[0])), fx.Name),
		"}",
	)
	return output
}

func kindToGoKind(protoKind string) string {
	switch protoKind {
	case "string":
		return "string"
	case "int32":
		return "int32"
	case "int64":
		return "int64"
	case "double":
		return "float64"
	}
}
