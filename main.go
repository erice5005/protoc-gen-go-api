package main

import (
	"fmt"
	"log"
	"strings"

	"github.com/fatih/camelcase"
	"google.golang.org/protobuf/compiler/protogen"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + ".go"

	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-api. DO NOT EDIT")
	g.P()
	g.P("package ", "internal")
	g.P()
	g.Write([]byte(`import ( "sample-protoc-api/proto/api" )`))
	g.P()
	// g.Import(file.GoDescriptorIdent.GoImportPath)
	// g.Import(file.GoImportPath)
	// g.Import(f  +"/proto/api.proto")
	// impt := protogen.GoImportPath()
	// g.P(fmt.Sprintf(`import %v`, file.Desc.Name()))
	// log.Printf("%v\n", file.Messages[0])
	protoNames := strings.Split(file.GeneratedFilenamePrefix, "/")
	protoName := protoNames[len(protoNames)-1]
	for _, msg := range file.Messages {
		mesgStruct := messageToStruct(msg, strings.ToLower(protoName))

		for _, msgS := range mesgStruct {
			g.P(msgS)
		}
	}
	return g
}

func messageToStruct(m *protogen.Message, protoName string) []string {

	mf := messageToFormat(m, protoName)
	mf.ProtoName = protoName
	st := generateStruct(mf)
	getters := makeGetters(mf)
	setters := makeSetters(mf)
	protos := makeToProto(mf)

	content := make([]string, 0)
	content = append(content, st...)
	content = append(content, getters...)
	content = append(content, setters...)
	content = append(content, protos...)
	return content
}

func capitalize(inp string) string {
	return fmt.Sprintf("%v%v", strings.ToUpper(string(inp[0])), inp[1:])
}

type GeneratableMessage struct {
	StructName string
	Fields     []MessageField
	RootProto  *protogen.Message
	ProtoName  string
}
type MessageField struct {
	Name        string
	JSONName    string
	Kind        string
	IsReference bool
	RootProto   *protogen.Field
}

func messageToFormat(m *protogen.Message, protoName string) GeneratableMessage {
	log.Print(fmt.Sprintf("%v.", protoName), string(m.Desc.FullName()))
	mx := GeneratableMessage{
		StructName: strings.Replace(string(m.Desc.FullName()), fmt.Sprintf("%v.", protoName), "", 1),
		Fields:     make([]MessageField, 0),
		RootProto:  m,
	}

	for _, fx := range m.Fields {
		// if fx.
		fName := strings.ToLower(strings.Join(camelcase.Split(fx.Desc.JSONName()), "_"))
		log.Printf("FName: %v\n", fName)
		mf := MessageField{
			Name:      fx.GoName,
			JSONName:  fName,
			RootProto: fx,
			// Kind:     kindToGoKind(fx.Desc.Kind().String()),
		}
		if fx.Message != nil {
			mf.IsReference = true
			mf.Kind = string(fx.Message.Desc.Name())
			// 	nested := messageToFormat(fx.Message)
			// 	mf.Fields = &nested
			// 	// log.Printf("FX: %v\n", fx)
		} else {
			mf.Kind = kindToGoKind(fx.Desc.Kind().String())
		}

		mx.Fields = append(mx.Fields, mf)
	}

	return mx
}

func generateStruct(m GeneratableMessage) []string {
	stringRows := make([]string, 0)
	// structName := strings.Replace(string(m.Desc.FullName()), "api.", "", 1)

	dataRows := make([]string, 0)
	for _, fx := range m.Fields {

		if fx.IsReference {

			dataRows = append(dataRows,
				fmt.Sprintf("%v *%v `json:\"%v\"`", fx.Name, fx.Kind, fx.JSONName),
			)
		} else {
			dataRows = append(dataRows,
				fmt.Sprintf("%v %v `json:\"%v\"`", fx.Name, fx.Kind, fx.JSONName),
			)
		}

		// }

	}

	stringRows = append(stringRows,
		fmt.Sprintf("type %v struct {", m.StructName),
	)
	stringRows = append(stringRows, dataRows...)
	stringRows = append(stringRows, "}")
	return stringRows
}

func makeGetters(m GeneratableMessage) []string {
	stringRows := make([]string, 0)

	for _, fx := range m.Fields {
		stringRows = append(stringRows, makeGetter(fx, m.StructName)...)
	}

	return stringRows
}

func makeGetter(fx MessageField, objName string) []string {
	output := make([]string, 0)
	if fx.IsReference {
		output = append(output,
			fmt.Sprintf("func (%v *%v) Get%v() *%v {", strings.ToLower(string(objName[0])), capitalize(objName), fx.Name, fx.Kind),
			fmt.Sprintf("return %v.%v", strings.ToLower(string(objName[0])), fx.Name),
			"}",
		)
	} else {
		output = append(output,
			fmt.Sprintf("func (%v *%v) Get%v() %v {", strings.ToLower(string(objName[0])), capitalize(objName), fx.Name, fx.Kind),
			fmt.Sprintf("return %v.%v", strings.ToLower(string(objName[0])), fx.Name),
			"}",
		)
	}

	return output
	// content := fmt.Sprintf("func (%v *%v) Get%v() %v {\n return %v.%v\n}",  )
}

func makeSetters(m GeneratableMessage) []string {
	stringRows := make([]string, 0)

	for _, fx := range m.Fields {
		stringRows = append(stringRows, makeSetter(fx, m.StructName)...)
	}

	return stringRows
}

func makeSetter(fx MessageField, objName string) []string {
	output := make([]string, 0)
	if fx.IsReference {
		output = append(output,
			fmt.Sprintf("func (%v *%v) Set%v(%v *%v) {", strings.ToLower(string(objName[0])), capitalize(objName), fx.Name, strings.ToLower(fx.Name), fx.Kind),
			fmt.Sprintf("%v.%v = %v", strings.ToLower(string(objName[0])), fx.Name, strings.ToLower(fx.Name)),
			"}",
		)
	} else {
		output = append(output,
			fmt.Sprintf("func (%v *%v) Set%v(%v %v) {", strings.ToLower(string(objName[0])), capitalize(objName), fx.Name, strings.ToLower(fx.Name), fx.Kind),
			fmt.Sprintf("%v.%v = %v", strings.ToLower(string(objName[0])), fx.Name, strings.ToLower(fx.Name)),
			"}",
		)
	}
	return output
}

func makeToProto(m GeneratableMessage) []string {
	stringRows := make([]string, 0)
	// structName := strings.Replace(string(m.Desc.FullName()), "api.", "", 1)

	dataRows := make([]string, 0)
	for _, fx := range m.Fields {
		if fx.IsReference {
			dataRows = append(dataRows,
				fmt.Sprintf("%v: %v.%v.ToProto(),", fx.RootProto.GoName, strings.ToLower(string(m.StructName[0])), fx.Name))
		} else {
			dataRows = append(dataRows,
				fmt.Sprintf("%v: %v.%v,", fx.RootProto.GoName, strings.ToLower(string(m.StructName[0])), fx.Name),
			)
		}

		// }

	}

	stringRows = append(stringRows,
		fmt.Sprintf("func (%v *%v) ToProto() *%v.%v {", strings.ToLower(string(m.StructName[0])), capitalize(m.StructName), m.ProtoName, m.RootProto.GoIdent.GoName),
		fmt.Sprintf("prt := &%v.%v{", m.ProtoName, m.RootProto.Desc.Name()),
	)
	stringRows = append(stringRows, dataRows...)
	stringRows = append(stringRows, "}")
	stringRows = append(stringRows, "return prt")
	stringRows = append(stringRows, "}")
	return stringRows
}

func kindToGoKind(protoKind string) string {
	switch protoKind {
	case "string":
		return "string"
	case "int32":
		return "int32"
	case "int64":
		return "int64"
	case "double":
		return "float64"
	default:
		return protoKind
	}
}
